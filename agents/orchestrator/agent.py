"""AD-VANCE: Research Orchestrator Agent

This is the main orchestration agent that coordinates all other agents
to execute complex Alzheimer's research workflows.
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Callable

from .prompts import (
    DECOMPOSITION_PROMPT,
    REFINEMENT_PROMPT,
    PLANNING_PROMPT,
)


logger = logging.getLogger(__name__)


class TaskStatus(Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    BLOCKED = "blocked"


class GoalType(Enum):
    BIOMARKER_DISCOVERY = "biomarker_discovery"
    DRUG_REPURPOSING = "drug_repurposing"
    DISEASE_SUBTYPING = "disease_subtyping"
    PROGRESSION_MODELING = "progression_modeling"
    PATHWAY_ANALYSIS = "pathway_analysis"
    GENERAL = "general"


@dataclass
class Task:
    """Represents a single task in the research workflow."""
    
    id: str
    description: str
    status: TaskStatus = TaskStatus.PENDING
    assigned_agent: str | None = None
    result: Any = None
    error: str | None = None
    dependencies: list[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    started_at: datetime | None = None
    completed_at: datetime | None = None
    metadata: dict = field(default_factory=dict)
    
    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "description": self.description,
            "status": self.status.value,
            "assigned_agent": self.assigned_agent,
            "result": str(self.result) if self.result else None,
            "error": self.error,
            "dependencies": self.dependencies,
            "created_at": self.created_at.isoformat(),
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "metadata": self.metadata,
        }


@dataclass
class Hypothesis:
    """Represents a research hypothesis generated by the system."""
    
    id: str
    description: str
    hypothesis_type: str
    confidence: float
    evidence_paths: list[str] = field(default_factory=list)
    supporting_agents: list[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    validation_results: dict = field(default_factory=dict)
    novelty_score: float = 0.0
    biological_plausibility: float = 0.0
    
    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "description": self.description,
            "type": self.hypothesis_type,
            "confidence": self.confidence,
            "evidence_paths": self.evidence_paths,
            "supporting_agents": self.supporting_agents,
            "created_at": self.created_at.isoformat(),
            "validation_results": self.validation_results,
            "novelty_score": self.novelty_score,
            "biological_plausibility": self.biological_plausibility,
        }


@dataclass
class ResearchGoal:
    """Represents a high-level research goal."""
    
    id: str
    description: str
    goal_type: GoalType
    tasks: list[Task] = field(default_factory=list)
    hypotheses: list[Hypothesis] = field(default_factory=list)
    status: TaskStatus = TaskStatus.PENDING
    created_at: datetime = field(default_factory=datetime.now)
    context: dict = field(default_factory=dict)
    
    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "description": self.description,
            "goal_type": self.goal_type.value,
            "status": self.status.value,
            "tasks": [t.to_dict() for t in self.tasks],
            "hypotheses": [h.to_dict() for h in self.hypotheses],
            "created_at": self.created_at.isoformat(),
            "context": self.context,
        }


class AgentRegistry:
    """Registry for all available agents in the system."""
    
    def __init__(self):
        self._agents: dict[str, Callable] = {}
    
    def register(self, name: str, agent: Callable) -> None:
        """Register an agent."""
        self._agents[name] = agent
        logger.info(f"Registered agent: {name}")
    
    def get(self, name: str) -> Callable | None:
        """Get an agent by name."""
        return self._agents.get(name)
    
    def list_agents(self) -> list[str]:
        """List all registered agents."""
        return list(self._agents.keys())


class ResearchOrchestrator:
    """Main orchestrator for the AD-VANCE system.
    
    Coordinates all agents to execute complex Alzheimer's research workflows.
    Implements autonomous planning, task decomposition, and hypothesis refinement.
    """
    
    def __init__(
        self,
        llm: Any | None = None,
        max_iterations: int = 10,
        enable_refinement: bool = True,
    ):
        """Initialize the orchestrator.
        
        Args:
            llm: Language model for reasoning. If None, uses rule-based planning.
            max_iterations: Maximum refinement iterations per goal.
            enable_refinement: Whether to enable hypothesis refinement loops.
        """
        self.llm = llm
        self.max_iterations = max_iterations
        self.enable_refinement = enable_refinement
        
        self.agent_registry = AgentRegistry()
        self.goals: dict[str, ResearchGoal] = {}
        
        self._setup_logging()
        self._register_default_agents()
        
        logger.info("Research Orchestrator initialized")
    
    def _setup_logging(self) -> None:
        """Configure logging for the orchestrator."""
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        )
    
    def _register_default_agents(self) -> None:
        """Register the default system agents."""
        from ..data_integration.agent import DataIntegrationAgent
        from ..knowledge_graph.agent import KnowledgeGraphAgent
        from ..hypothesis_generation.agent import HypothesisGenerationAgent
        from ..validation.agent import ValidationAgent
        from ..reproducibility.agent import ReproducibilityAgent
        
        self.agent_registry.register("data_integration", DataIntegrationAgent)
        self.agent_registry.register("knowledge_graph", KnowledgeGraphAgent)
        self.agent_registry.register("hypothesis_generation", HypothesisGenerationAgent)
        self.agent_registry.register("validation", ValidationAgent)
        self.agent_registry.register("reproducibility", ReproducibilityAgent)
    
    def register_agent(self, name: str, agent: Callable) -> None:
        """Register a custom agent."""
        self.agent_registry.register(name, agent)
    
    def _classify_goal(self, description: str) -> GoalType:
        """Classify the goal type based on description."""
        description_lower = description.lower()
        
        if any(kw in description_lower for kw in ["biomarker", "biomarker", "early detection", "diagnosis"]):
            return GoalType.BIOMARKER_DISCOVERY
        elif any(kw in description_lower for kw in ["drug", "repurposing", "therapy", "treatment"]):
            return GoalType.DRUG_REPURPOSING
        elif any(kw in description_lower for kw in ["subtype", "cluster", "stratification", "subgroup"]):
            return GoalType.DISEASE_SUBTYPING
        elif any(kw in description_lower for kw in ["progression", "predict", "outcome", "survival"]):
            return GoalType.PROGRESSION_MODELING
        elif any(kw in description_lower for kw in ["pathway", "mechanism", "causal", "pathogenesis"]):
            return GoalType.PATHWAY_ANALYSIS
        else:
            return GoalType.GENERAL
    
    def _decompose_goal(self, goal: ResearchGoal) -> list[Task]:
        """Decompose a high-level goal into executable tasks."""
        logger.info(f"Decomposing goal: {goal.description}")
        
        tasks = []
        
        goal_type_handlers = {
            GoalType.BIOMARKER_DISCOVERY: self._create_biomarker_tasks,
            GoalType.DRUG_REPURPOSING: self._create_drug_repurposing_tasks,
            GoalType.DISEASE_SUBTYPING: self._create_subtyping_tasks,
            GoalType.PROGRESSION_MODELING: self._create_progression_tasks,
            GoalType.PATHWAY_ANALYSIS: self._create_pathway_tasks,
            GoalType.GENERAL: self._create_general_tasks,
        }
        
        task_creator = goal_type_handlers.get(goal.goal_type, self._create_general_tasks)
        tasks = task_creator(goal)
        
        logger.info(f"Created {len(tasks)} tasks for goal {goal.id}")
        return tasks
    
    def _create_biomarker_tasks(self, goal: ResearchGoal) -> list[Task]:
        """Create tasks for biomarker discovery."""
        return [
            Task(
                id=f"{goal.id}_task_1",
                description="Collect and integrate multi-omic data from ADNI, AMP-AD, ROSMAP",
                assigned_agent="data_integration",
                dependencies=[],
            ),
            Task(
                id=f"{goal.id}_task_2",
                description="Build Alzheimer's knowledge graph with genes, proteins, pathways",
                assigned_agent="knowledge_graph",
                dependencies=[f"{goal.id}_task_1"],
            ),
            Task(
                id=f"{goal.id}_task_3",
                description="Generate biomarker combination hypotheses using pattern mining",
                assigned_agent="hypothesis_generation",
                dependencies=[f"{goal.id}_task_1", f"{goal.id}_task_2"],
            ),
            Task(
                id=f"{goal.id}_task_4",
                description="Validate biomarker hypotheses through cross-validation and survival analysis",
                assigned_agent="validation",
                dependencies=[f"{goal.id}_task_3"],
            ),
            Task(
                id=f"{goal.id}_task_5",
                description="Log all decisions and generate reproducibility report",
                assigned_agent="reproducibility",
                dependencies=[f"{goal.id}_task_4"],
            ),
        ]
    
    def _create_drug_repurposing_tasks(self, goal: ResearchGoal) -> list[Task]:
        """Create tasks for drug repurposing."""
        return [
            Task(
                id=f"{goal.id}_task_1",
                description="Integrate drug-target interactions and AD genetic data",
                assigned_agent="data_integration",
                dependencies=[],
            ),
            Task(
                id=f"{goal.id}_task_2",
                description="Build drug-disease knowledge graph",
                assigned_agent="knowledge_graph",
                dependencies=[f"{goal.id}_task_1"],
            ),
            Task(
                id=f"{goal.id}_task_3",
                description="Identify drug repurposing candidates using network proximity",
                assigned_agent="hypothesis_generation",
                dependencies=[f"{goal.id}_task_2"],
            ),
            Task(
                id=f"{goal.id}_task_4",
                description="Validate candidates through clinical trial analysis",
                assigned_agent="validation",
                dependencies=[f"{goal.id}_task_3"],
            ),
            Task(
                id=f"{goal.id}_task_5",
                description="Generate transparency report",
                assigned_agent="reproducibility",
                dependencies=[f"{goal.id}_task_4"],
            ),
        ]
    
    def _create_subtyping_tasks(self, goal: ResearchGoal) -> list[Task]:
        """Create tasks for disease subtyping."""
        return [
            Task(
                id=f"{goal.id}_task_1",
                description="Collect multi-modal patient data",
                assigned_agent="data_integration",
                dependencies=[],
            ),
            Task(
                id=f"{goal.id}_task_2",
                description="Build patient similarity network",
                assigned_agent="knowledge_graph",
                dependencies=[f"{goal.id}_task_1"],
            ),
            Task(
                id=f"{goal.id}_task_3",
                description="Perform clustering and subtype identification",
                assigned_agent="hypothesis_generation",
                dependencies=[f"{goal.id}_task_2"],
            ),
            Task(
                id=f"{goal.id}_task_4",
                description="Validate subtypes with clinical outcomes",
                assigned_agent="validation",
                dependencies=[f"{goal.id}_task_3"],
            ),
            Task(
                id=f"{goal.id}_task_5",
                description="Generate reproducibility documentation",
                assigned_agent="reproducibility",
                dependencies=[f"{goal.id}_task_4"],
            ),
        ]
    
    def _create_progression_tasks(self, goal: ResearchGoal) -> list[Task]:
        """Create tasks for progression modeling."""
        return [
            Task(
                id=f"{goal.id}_task_1",
                description="Collect longitudinal data and clinical endpoints",
                assigned_agent="data_integration",
                dependencies=[],
            ),
            Task(
                id=f"{goal.id}_task_2",
                description="Build temporal knowledge graph",
                assigned_agent="knowledge_graph",
                dependencies=[f"{goal.id}_task_1"],
            ),
            Task(
                id=f"{goal.id}_task_3",
                description="Develop progression prediction models",
                assigned_agent="hypothesis_generation",
                dependencies=[f"{goal.id}_task_2"],
            ),
            Task(
                id=f"{goal.id}_task_4",
                description="Validate with survival analysis and risk stratification",
                assigned_agent="validation",
                dependencies=[f"{goal.id}_task_3"],
            ),
            Task(
                id=f"{goal.id}_task_5",
                description="Generate reproducibility audit",
                assigned_agent="reproducibility",
                dependencies=[f"{goal.id}_task_4"],
            ),
        ]
    
    def _create_pathway_tasks(self, goal: ResearchGoal) -> list[Task]:
        """Create tasks for pathway analysis."""
        return [
            Task(
                id=f"{goal.id}_task_1",
                description="Collect multi-omic pathway data",
                assigned_agent="data_integration",
                dependencies=[],
            ),
            Task(
                id=f"{goal.id}_task_2",
                description="Build pathway interaction network",
                assigned_agent="knowledge_graph",
                dependencies=[f"{goal.id}_task_1"],
            ),
            Task(
                id=f"{goal.id}_task_3",
                description="Identify causal pathways using causal inference",
                assigned_agent="hypothesis_generation",
                dependencies=[f"{goal.id}_task_2"],
            ),
            Task(
                id=f"{goal.id}_task_4",
                description="Validate pathway hypotheses",
                assigned_agent="validation",
                dependencies=[f"{goal.id}_task_3"],
            ),
            Task(
                id=f"{goal.id}_task_5",
                description="Generate pathway enrichment report",
                assigned_agent="reproducibility",
                dependencies=[f"{goal.id}_task_4"],
            ),
        ]
    
    def _create_general_tasks(self, goal: ResearchGoal) -> list[Task]:
        """Create general tasks for any goal type."""
        return [
            Task(
                id=f"{goal.id}_task_1",
                description="Data collection and preprocessing",
                assigned_agent="data_integration",
                dependencies=[],
            ),
            Task(
                id=f"{goal.id}_task_2",
                description="Knowledge graph construction",
                assigned_agent="knowledge_graph",
                dependencies=[f"{goal.id}_task_1"],
            ),
            Task(
                id=f"{goal.id}_task_3",
                description="Hypothesis generation",
                assigned_agent="hypothesis_generation",
                dependencies=[f"{goal.id}_task_2"],
            ),
            Task(
                id=f"{goal.id}_task_4",
                description="Hypothesis validation",
                assigned_agent="validation",
                dependencies=[f"{goal.id}_task_3"],
            ),
            Task(
                id=f"{goal.id}_task_5",
                description="Generate reproducibility report",
                assigned_agent="reproducibility",
                dependencies=[f"{goal.id}_task_4"],
            ),
        ]
    
    def _execute_task(self, task: Task) -> Any:
        """Execute a single task using the assigned agent."""
        logger.info(f"Executing task {task.id}: {task.description}")
        
        task.status = TaskStatus.IN_PROGRESS
        task.started_at = datetime.now()
        
        agent_factory = self.agent_registry.get(task.assigned_agent)
        
        if agent_factory is None:
            logger.error(f"Agent not found: {task.assigned_agent}")
            task.status = TaskStatus.FAILED
            task.error = f"Agent not found: {task.assigned_agent}"
            return None
        
        try:
            agent = agent_factory()
            result = agent.execute(task.description, context=task.metadata)
            task.result = result
            task.status = TaskStatus.COMPLETED
            task.completed_at = datetime.now()
            logger.info(f"Task {task.id} completed successfully")
            return result
        except Exception as e:
            logger.error(f"Task {task.id} failed: {str(e)}")
            task.status = TaskStatus.FAILED
            task.error = str(e)
            task.completed_at = datetime.now()
            return None
    
    def _can_execute_task(self, task: Task) -> bool:
        """Check if a task's dependencies are met."""
        for dep_id in task.dependencies:
            dep_task = self._find_task(dep_id)
            if dep_task and dep_task.status != TaskStatus.COMPLETED:
                return False
        return True
    
    def _find_task(self, task_id: str) -> Task | None:
        """Find a task by ID across all goals."""
        for goal in self.goals.values():
            for task in goal.tasks:
                if task.id == task_id:
                    return task
        return None
    
    def _execute_goal(self, goal: ResearchGoal) -> ResearchGoal:
        """Execute all tasks for a goal."""
        logger.info(f"Executing goal: {goal.description}")
        
        goal.tasks = self._decompose_goal(goal)
        
        completed_count = 0
        iteration = 0
        
        while completed_count < len(goal.tasks) and iteration < self.max_iterations:
            iteration += 1
            completed_count = 0
            
            for task in goal.tasks:
                if task.status == TaskStatus.COMPLETED:
                    completed_count += 1
                elif task.status == TaskStatus.PENDING and self._can_execute_task(task):
                    self._execute_task(task)
            
            if completed_count < len(goal.tasks):
                logger.info(f"Progress: {completed_count}/{len(goal.tasks)} tasks completed")
        
        goal.status = TaskStatus.COMPLETED
        logger.info(f"Goal {goal.id} execution complete")
        return goal
    
    def _refine_hypotheses(self, goal: ResearchGoal) -> None:
        """Refine hypotheses based on validation results."""
        if not self.enable_refinement:
            return
        
        logger.info(f"Refining {len(goal.hypotheses)} hypotheses")
        
        for hypothesis in goal.hypotheses:
            if hypothesis.validation_results.get("passed", False):
                continue
            
            refinement_prompt = REFINEMENT_PROMPT.format(
                hypothesis=hypothesis.description,
                validation=json.dumps(hypothesis.validation_results),
            )
            
            if self.llm:
                try:
                    refined = self.llm.invoke(refinement_prompt)
                    hypothesis.description = refined.content
                except Exception as e:
                    logger.warning(f"Refinement failed for {hypothesis.id}: {e}")
    
    def execute_goal(self, description: str, context: dict | None = None) -> ResearchGoal:
        """Execute a research goal end-to-end.
        
        Args:
            description: The high-level research goal description
            context: Additional context for the goal
            
        Returns:
            ResearchGoal with completed tasks and generated hypotheses
        """
        import uuid
        
        goal_id = str(uuid.uuid4())[:8]
        
        goal = ResearchGoal(
            id=goal_id,
            description=description,
            goal_type=self._classify_goal(description),
            context=context or {},
        )
        
        self.goals[goal_id] = goal
        
        goal = self._execute_goal(goal)
        
        self._refine_hypotheses(goal)
        
        logger.info(f"Goal {goal_id} execution finished with {len(goal.hypotheses)} hypotheses")
        return goal
    
    def get_goal_status(self, goal_id: str) -> dict:
        """Get the status of a goal."""
        goal = self.goals.get(goal_id)
        if goal is None:
            return {"error": "Goal not found"}
        return goal.to_dict()
    
    def list_goals(self) -> list[dict]:
        """List all goals."""
        return [goal.to_dict() for goal in self.goals.values()]
    
    def cancel_goal(self, goal_id: str) -> bool:
        """Cancel a goal and its tasks."""
        goal = self.goals.get(goal_id)
        if goal is None:
            return False
        
        for task in goal.tasks:
            if task.status == TaskStatus.PENDING:
                task.status = TaskStatus.FAILED
                task.error = "Cancelled by user"
        
        goal.status = TaskStatus.FAILED
        return True
